import os
import subprocess
import json
import logging
from datetime import datetime
from core.error_handler import ErrorHandler

def run_nuclei_scan(target, output_callback=None, verbose=False):
    """
    Run Nuclei vulnerability scan against a target
    
    :param target: Domain or URL to scan
    :param output_callback: Function to receive real-time output
    :param verbose: Whether to show detailed output
    :return: Dictionary of scan results
    """
    results = {
        "target": target,
        "start_time": datetime.now().isoformat(),
        "vulnerabilities": [],
        "status": "completed"
    }
    
    try:
        # Prepare output file
        output_dir = "outputs/vulnerabilities"
        os.makedirs(output_dir, exist_ok=True)
        output_file = os.path.join(output_dir, f"nuclei_{target.replace('.', '_')}.json")
        
        # Build Nuclei command
        cmd = [
            "nuclei",
            "-u", target,
            "-json",
            "-silent",
            "-timeout", "30",
            "-retries", "2",
            "-rate-limit", "100",
            "-o", output_file
        ]
        
        if verbose:
            cmd.remove("-silent")
            if output_callback:
                output_callback("nuclei", f"Running command: {' '.join(cmd)}")
        
        # Execute Nuclei
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )
        
        # Process real-time output
        for line in iter(process.stdout.readline, ''):
            if output_callback and verbose:
                output_callback("nuclei", line.strip())
            
            # Try to parse JSON lines
            if line.startswith('{'):
                try:
                    vuln = json.loads(line)
                    results["vulnerabilities"].append({
                        "id": vuln.get("id", ""),
                        "name": vuln.get("name", ""),
                        "severity": vuln.get("severity", "unknown"),
                        "url": vuln.get("matched", ""),
                        "description": vuln.get("description", "")
                    })
                except json.JSONDecodeError:
                    continue
        
        process.wait()
        results["end_time"] = datetime.now().isoformat()
        
        # If we didn't get real-time results, load from file
        if not results["vulnerabilities"] and os.path.exists(output_file):
            with open(output_file, 'r') as f:
                for line in f:
                    try:
                        vuln = json.loads(line)
                        results["vulnerabilities"].append({
                            "id": vuln.get("id", ""),
                            "name": vuln.get("name", ""),
                            "severity": vuln.get("severity", "unknown"),
                            "url": vuln.get("matched", ""),
                            "description": vuln.get("description", "")
                        })
                    except:
                        continue
        
        # Add statistics
        results["total_vulnerabilities"] = len(results["vulnerabilities"])
        results["severity_counts"] = {
            "critical": sum(1 for v in results["vulnerabilities"] if v["severity"] == "critical"),
            "high": sum(1 for v in results["vulnerabilities"] if v["severity"] == "high"),
            "medium": sum(1 for v in results["vulnerabilities"] if v["severity"] == "medium"),
            "low": sum(1 for v in results["vulnerabilities"] if v["severity"] == "low"),
            "info": sum(1 for v in results["vulnerabilities"] if v["severity"] == "info")
        }
        
        return results
        
    except Exception as e:
        ErrorHandler.log_error("nuclei", str(e), target)
        results["status"] = "failed"
        results["error"] = str(e)
        return results

# For backward compatibility with older imports
def run(target, progress_callback=None):
    """Legacy run function for compatibility"""
    return run_nuclei_scan(target)